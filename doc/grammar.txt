More or less formal definition of the grammar of the Sparkling language.
Any syntactical or semantical errors in the grammar and all the deviations from
the (theoretically correct) reference implementation are unintentional.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Grammar notations:

- Specifying a production (precedence level 0, lowest):

	production = rule
    
- Listing compulsory, successive parts of a rule (precedence level 1):

	part1 part2 part3 ... partN

- Providing multiple (alternative) choices (precedence level 2):

	rule1 | rule2 | rule3 | ... | ruleN

- Quantifiers:
 
	? -- 0 or 1 ("optional")
	* -- 0 or more ("optional, may be repeated")
	+ -- 1 or more ("obligatory, may be repeated")

- Optional language construct - zero or one occurrence (acts as grouping, too -> precedence level 3):

	[ rules... ]

- Optional language construct - zero or more occurrences (acts as grouping, too -> precedence level 3):

	{ rules... }

- Grouping without side effects ("parenthesizing"; precedence level 3):

	( rules... )

- Literal strings (terminals):

	'string'

- Other terminals:

	IN-ALL-CAPS

The language ignores whitespace between tokens (terminals). Comments are treated
as whitespace (they're ignored). One-line comments begin with '//' or '#',
whereas block comments are enclosed between '/*' and '*/'.

and they don't nest.

T h e   g r a m m a r
~~~~~~~~~~~~~~~~~~~~~

program				= ( statement | function-statement | const-statement )(*)

argument-declaration-list	= ( IDENT ( ',' IDENT )(*) )(?)

statement = empty-statement              |
            if-statement                 |
            loop-statement               |
            return-statement             |
            loop-control-flow-statement  |
            expression-statement         |
            block-statement              |
            variable-declaration

function-statement  = 'function' IDENT '(' argument-declaration-list ')' block-statement

const-statement     = 'const' | 'global' IDENT '=' expression ( ',' IDENT '=' expression )(*) ';'

empty-statement     = ';'

if-statement        = 'if' expression block-statement ( 'else' block-statement | if-statement )(?)

loop-statement      = for-statement      |
                      while-statement    |
                      do-while-statement

for-statement       = 'for' for-header | ( '(' for-header ')' ) block-statement
for-header          = ( variable-declaration | expression ';' ) expression ';' expression

while-statement     = 'while' expression block-statement

do-while-statement  = 'do' block-statement 'while' expression ';'

return-statement    = 'return' [ expression ] ';'

block-statement     = '{' statement (*) '}'

loop-control-flow-statement = 'break' | 'continue' ';'

variable-declaration  = 'var' | 'let' IDENT [ '=' expression ] ( ',' IDENT [ '=' expression ] )(*) ';'

expression-statement  = expression ';'

expression            = assignment-expr

assignment-expr       = concat-expr [
                      (  '=' |
                        '+=' |
                        '-=' |
                        '*=' |
                        '/=' |
                        '%=' |
                        '|=' |
                        '&=' |
                        '^=' |
                       '<<=' |
                       '>>=' )
                        assignment-expr ] /* right-assoc */

concat-expr           = [cond-expr '..' ] cond-expr /* left-assoc */

cond-expr             = logical-or-expr [ '?' expression ':' cond-expr ] /* right-assoc */

logical-or-expr       = [ logical-and-expr '||' ] logical-and-expr /* left-assoc */

logical-and-expr      = [ comparison-expr '&&' ] comparison-expr 

comparison-expr       = [ bitwise-or-expr '<' | '>' | '<=' | '>=' | '==' | '!=' ] bitwise-or-expr

bitwise-or-expr       = [ bitwise-xor-expr '|' ] bitwise-xor-expr

bitwise-xor-expr      = [ bitwise-and-expr '^' ] bitwise-and-expr

bitwise-and-expr      = [ shift-expr '&' ] shift-expr

shift-expr            = [ additive-expr '<<' | '>>' ] additive-expr

additive-expr         = [ multplicative-expr '+' | '-' ] multiplicative-expr

multiplicative-expr   = [ prefix-expr '*' | '/' | '%' ] prefix-expr

prefix-expr           = (
                      ( '+'       |
                        '-'       |
                        '++'      |
                        '--'      |
                        '!'       |
                        '~'       |
                        'typeof'  )
                      prefix-expr ) | postfix-expr /* right-assoc */

postfix-expr = term
        (
          ( '[' expression ']' )              |
          ( '(' [ argument-call-list ] ')' )  |
          '++'                                |
          '--'                                |
          ( '.' IDENT )                       |
          ( '::' IDENT )
        )(*) /* left-assoc */

term         = IDENT                   |
               literal                 |
               'argc'                  |
               'argv'                  |
               ( '(' expression ')' )  |
               function-expr           |
               array-expr

function-expr  = 'function' [ IDENT ] '(' argument-declaration-list ')' block-statement

array-expr     = '{' [ key-val ( ',' key-val )(*) ] '}'

key-val        = expression [ ':' expression ]

argument-call-list = ( expression ( ',' expression )(*) )(?)

literal  =   STRING   |
             INTEGER  |
             CHAR     |
             FLOAT    |
            'true'    |
            'false'   |
            'nil'     |
            'null'

Reserved keywords
~~~~~~~~~~~~~~~~~

and         else        if        return
argc        false       let       true
break       for         nil       typeof
const       function    not       var
continue    global      null      while
do                      return


The 'not', 'and' and 'or' keywords are equivalent with the '!', '&&' and '||'
tokens, respectively. Furthermore, 'null' is the same as 'nil'; 'global' is
the same as 'const'; and 'let' is the same as 'var'.

Literal tokens:
~~~~~~~~~~~~~~~

string-char  = /[^"\\]/

chrlit-char  = /[^'\\]/

escape       = /\\[\\/'"abfnrt0]/ | /\\x[0-9a-fA-F]{2}/

STRING       = '"' ( string-char | escape )(*) '"'

CHAR         = '\'' ( chrlit-char | escape ){1, 8} '\''/

decimal      = /[1-9][0-9]*/

octal        = /0[0-7]+/

hex          = /0x[0-9a-fA-F]+/

INTEGER      = decimal  |
               octal    |
               hex

exponent     = /[eE][+-]?\d+/

FLOAT        = [ decimal ] /\.\d+/ [ exponent ]
               | decimal   /\.\d*/ [ exponent ]

IDENT        = /[a-zA-Z_][a-zA-Z0-9_]*/

Valid escape sequences:
~~~~~~~~~~~~~~~~~~~~~~~
The same as in C:
 - \\	->	\
 - \/	->	/
 - \'	->	'
 - \"	->	"
 - \a	->	bell
 - \b	->	backspace
 - \f	->	form feed
 - \n	->	LF
 - \r	->	CR
 - \t	->	TAB
 - \0	->	NUL, char code 0
 - \xHH      ->	the character with code HH, where HH denotes two hexadecimal digits

Sparkling source files preferrably use UTF-8 (or ASCII), but nothing else is prohibited.
(Read: please facilitate our lives and DO USE UTF-8, unless you really really can't.)

